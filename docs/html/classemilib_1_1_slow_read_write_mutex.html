<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>emilib: emilib::SlowReadWriteMutex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emilib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>emilib</b></li><li class="navelem"><a class="el" href="classemilib_1_1_slow_read_write_mutex.html">SlowReadWriteMutex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classemilib_1_1_slow_read_write_mutex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">emilib::SlowReadWriteMutex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="read__write__mutex_8hpp_source.html">read_write_mutex.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf0cad45ff275c7e07bcbaa21208d5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemilib_1_1_slow_read_write_mutex.html#acf0cad45ff275c7e07bcbaa21208d5ab">lock</a> ()</td></tr>
<tr class="separator:acf0cad45ff275c7e07bcbaa21208d5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66392705ff4998b9eb0ffecef0dc9b4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemilib_1_1_slow_read_write_mutex.html#a66392705ff4998b9eb0ffecef0dc9b4a">try_lock</a> ()</td></tr>
<tr class="separator:a66392705ff4998b9eb0ffecef0dc9b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305eae2ad0d2b65005cc4c78f3b33430"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a305eae2ad0d2b65005cc4c78f3b33430"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock</b> ()</td></tr>
<tr class="separator:a305eae2ad0d2b65005cc4c78f3b33430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253c927c6d56b10decebe7b6bb34ae09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemilib_1_1_slow_read_write_mutex.html#a253c927c6d56b10decebe7b6bb34ae09">lock_shared</a> ()</td></tr>
<tr class="separator:a253c927c6d56b10decebe7b6bb34ae09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6356a239b6fef2e5495f322307d0f36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemilib_1_1_slow_read_write_mutex.html#aa6356a239b6fef2e5495f322307d0f36">try_lock_shared</a> ()</td></tr>
<tr class="separator:aa6356a239b6fef2e5495f322307d0f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67359bb0bc3fa0d53ba291dab182dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemilib_1_1_slow_read_write_mutex.html#aa67359bb0bc3fa0d53ba291dab182dc6">unlock_shared</a> ()</td></tr>
<tr class="separator:aa67359bb0bc3fa0d53ba291dab182dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a good mutex if reading is slow to save on CPU usage when there is a thread waiting to write. This is a drop-in replacement for C++17's std::shared_mutex. This mutex is NOT recursive! </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acf0cad45ff275c7e07bcbaa21208d5ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emilib::SlowReadWriteMutex::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locks the mutex for exclusive access (e.g. for a write operation). If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired. If lock is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined. </p>

</div>
</div>
<a class="anchor" id="a253c927c6d56b10decebe7b6bb34ae09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emilib::SlowReadWriteMutex::lock_shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquires shared ownership of the mutex (e.g. for a read operation). If another thread is holding the mutex in exclusive ownership, a call to lock_shared will block execution until shared ownership can be acquired. </p>

</div>
</div>
<a class="anchor" id="a66392705ff4998b9eb0ffecef0dc9b4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emilib::SlowReadWriteMutex::try_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false. This function is allowed to fail spuriously and return false even if the mutex is not currently locked by any other thread. If try_lock is called by a thread that already owns the mutex, the behavior is undefined. </p>

</div>
</div>
<a class="anchor" id="aa6356a239b6fef2e5495f322307d0f36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emilib::SlowReadWriteMutex::try_lock_shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to lock the mutex in shared mode. Returns immediately. On successful lock acquisition returns true, otherwise returns false. This function is allowed to fail spuriously and return false even if the mutex is not currenly exclusively locked by any other thread. </p>

</div>
</div>
<a class="anchor" id="aa67359bb0bc3fa0d53ba291dab182dc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emilib::SlowReadWriteMutex::unlock_shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases the mutex from shared ownership by the calling thread. The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>emilib/<a class="el" href="read__write__mutex_8hpp_source.html">read_write_mutex.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
